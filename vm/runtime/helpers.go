// Code generated by vm/runtime/generate/main.go. DO NOT EDIT.

package runtime

import (
	"fmt"
	"reflect"
	"time"
)

func Equal(a, b interface{}) interface{} {
	switch x := a.(type) {
	case int:
		switch y := b.(type) {
		case int:
			return x == y
		case float64:
			return float64(x) == float64(y)
		}
	case float64:
		switch y := b.(type) {
		case int:
			return float64(x) == float64(y)
		case float64:
			return x == y
		}
	case string:
		switch y := b.(type) {
		case string:
			return x == y
		}
	case time.Time:
		switch y := b.(type) {
		case time.Time:
			return x.Equal(y)
		}
	}
	if IsNil(a) && IsNil(b) {
		return true
	}
	return reflect.DeepEqual(a, b)
}

func Less(a, b interface{}) interface{} {
	switch x := a.(type) {
	case int:
		switch y := b.(type) {
		case int:
			return x < y
		case float64:
			return float64(x) < float64(y)
		}
	case float64:
		switch y := b.(type) {
		case int:
			return float64(x) < float64(y)
		case float64:
			return x < y
		}
	case string:
		switch y := b.(type) {
		case string:
			return x < y
		}
	case time.Time:
		switch y := b.(type) {
		case time.Time:
			return x.Before(y)
		}
	}
	panic(fmt.Sprintf("invalid operation: %T < %T", a, b))
}

func More(a, b interface{}) interface{} {
	switch x := a.(type) {
	case int:
		switch y := b.(type) {
		case int:
			return x > y
		case float64:
			return float64(x) > float64(y)
		}
	case float64:
		switch y := b.(type) {
		case int:
			return float64(x) > float64(y)
		case float64:
			return x > y
		}
	case string:
		switch y := b.(type) {
		case string:
			return x > y
		}
	case time.Time:
		switch y := b.(type) {
		case time.Time:
			return x.After(y)
		}
	}
	panic(fmt.Sprintf("invalid operation: %T > %T", a, b))
}

func LessOrEqual(a, b interface{}) interface{} {
	switch x := a.(type) {
	case int:
		switch y := b.(type) {
		case int:
			return x <= y
		case float64:
			return float64(x) <= float64(y)
		}
	case float64:
		switch y := b.(type) {
		case int:
			return float64(x) <= float64(y)
		case float64:
			return x <= y
		}
	case string:
		switch y := b.(type) {
		case string:
			return x <= y
		}
	case time.Time:
		switch y := b.(type) {
		case time.Time:
			return x.Before(y) || x.Equal(y)
		}
	}
	panic(fmt.Sprintf("invalid operation: %T <= %T", a, b))
}

func MoreOrEqual(a, b interface{}) interface{} {
	switch x := a.(type) {
	case int:
		switch y := b.(type) {
		case int:
			return x >= y
		case float64:
			return float64(x) >= float64(y)
		}
	case float64:
		switch y := b.(type) {
		case int:
			return float64(x) >= float64(y)
		case float64:
			return x >= y
		}
	case string:
		switch y := b.(type) {
		case string:
			return x >= y
		}
	case time.Time:
		switch y := b.(type) {
		case time.Time:
			return x.After(y) || x.Equal(y)
		}
	}
	panic(fmt.Sprintf("invalid operation: %T >= %T", a, b))
}

func Add(a, b interface{}) interface{} {
	switch x := a.(type) {
	case int:
		switch y := b.(type) {
		case int:
			return x + y
		case float64:
			return float64(x) + float64(y)
		}
	case float64:
		switch y := b.(type) {
		case int:
			return float64(x) + float64(y)
		case float64:
			return x + y
		}
	case string:
		switch y := b.(type) {
		case string:
			return x + y
		}
	case time.Time:
		switch y := b.(type) {
		case time.Duration:
			return x.Add(y)
		}
	case time.Duration:
		switch y := b.(type) {
		case time.Time:
			return y.Add(x)
		}
	}
	panic(fmt.Sprintf("invalid operation: %T + %T", a, b))
}

func Subtract(a, b interface{}) interface{} {
	switch x := a.(type) {
	case int:
		switch y := b.(type) {
		case int:
			return x - y
		case float64:
			return float64(x) - float64(y)
		}
	case float64:
		switch y := b.(type) {
		case int:
			return float64(x) - float64(y)
		case float64:
			return x - y
		}
	case time.Time:
		switch y := b.(type) {
		case time.Time:
			return x.Sub(y)
		}
	}
	panic(fmt.Sprintf("invalid operation: %T - %T", a, b))
}

func Multiply(a, b interface{}) interface{} {
	switch x := a.(type) {
	case int:
		switch y := b.(type) {
		case int:
			return x * y
		case float64:
			return float64(x) * float64(y)
		}
	case float64:
		switch y := b.(type) {
		case int:
			return float64(x) * float64(y)
		case float64:
			return x * y
		}
	}
	panic(fmt.Sprintf("invalid operation: %T * %T", a, b))
}

func Divide(a, b interface{}) interface{} {
	switch x := a.(type) {
	case int:
		switch y := b.(type) {
		case int:
			return x / y
		case float64:
			return float64(x) / float64(y)
		}
	case float64:
		switch y := b.(type) {
		case int:
			return float64(x) / float64(y)
		case float64:
			return x / y
		}
	}
	panic(fmt.Sprintf("invalid operation: %T / %T", a, b))
}

func Modulo(a, b interface{}) interface{} {
	switch x := a.(type) {
	case int:
		switch y := b.(type) {
		case int:
			return x % y
		}
	}
	panic(fmt.Sprintf("invalid operation: %T %% %T", a, b))
}
